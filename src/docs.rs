use crate::{
    aredl, arepl, auth, clans, get_secret, health, notifications, roles, shifts, users, utils,
};
use serde_json::json;
use utoipa::openapi::extensions::Extensions;
use utoipa::openapi::path::Operation;
use utoipa::openapi::security::{ApiKey, ApiKeyValue, HttpAuthScheme, HttpBuilder, SecurityScheme};
use utoipa::openapi::{PathItem, Server};
use utoipa::{Modify, OpenApi};

const API_DESCRIPTION: &str = r#"
# Welcome to the AREDL API v2 Documentation!

## Useful Links
**Base URL**: https://api.aredl.net/v2/api  
**Github Organization**: https://github.com/All-Rated-Extreme-Demon-List/  
**Public Website**: https://aredl.net  
**Discord Server**: https://discord.gg/aredl  

## Endpoints
You can find below each category of endpoints and their description:

| Category | Description |
|---|---|
| **AREDL** | Various endpoints for fetching AREDL data automatically generated by the database |
| **AREDL - Levels** | Endpoints for fetching and managing the list and levels data on the AREDL |
| **AREDL - Levels (Creators)** | Endpoints for fetching and managing the creators list of a specific AREDL level |
| **AREDL - Submissions** | Endpoints for fetching and managing AREDL submissions, both for users and staff |
| **AREDL - Records** | Endpoints for fetching and managing AREDL records |
| **AREDL - Packs** | Staff only endpoints used to manage AREDL packs. To fetch packs data, use Pack Tiers endpoints instead. |
| **AREDL - Pack Tiers** | Endpoints to fetch and manage AREDL pack tiers |
| **AREDL (P)** | All previous AREDL specific endpoints duplicated for platformer mode |
| **Authentication** | Endpoints for authenticating with Discord and managing api keys |
| **Roles** | Endpoints for fetching and managing the roles and their assigned users |
| **Users** | Endpoints for fetching and managing the list of users |
| **Users - Me** | Endpoints for fetching and managing the authenticated user and other related information |
| **Users - Merges** | Endpoints for merging users and submitting/managing merge requests |
| **Clans** | Endpoints for fetching and managing clans |
| **Clans - Members** | Endpoints for fetching, inviting and managing members of a clan |
| **Shifts** | Staff endpoints to fetch and manage staff shifts for reviewing records |
| **Notifications** | Endpoints for opening a web socket to receive real time data from the API |
| **Health** | Endpoints for checking whether the API is online or not |

In addition to that, endpoints are also categorized by the type of authentication they require:

| Type | Description |
|---|---|
| **Public** | Publicly available endpoints that do not require authentication |
| **Authed User** | Endpoints that require you to be authenticated but do not require any permission |
| **Public / Authed** | Publicly available but behave differently or offer additional features if authenticated |
| **Staff Only** | Endpoints that require a specific permission |

You can find what type an endpoint is by looking at the tags at the top of its page.

## Authentication
You can authenticate using either a bearer token or an API key.

There are two types of tokens:
- **Access Token**: Used to make authenticated requests. Expires after 30 minutes.
- **Refresh Token**: Used to get a new access token. Expires after 2 weeks.

The refresh token cannot be used on classic endpoints, but is the only one that can be used on the refresh endpoint to get a new access token. If the refresh token is about to expire, it will also return a new refresh token.

API keys can be created through the AREDL website settings or the API key endpoint and have a custom lifetime. They can be used as a regular bearer token.

You can invalidate all active tokens using the Logout All endpoint.

## Allowed video URL types
Some submissions endpoints accept `video_url` (completion video) and `raw_url` (raw footage):

- **Completion video (`video_url`)**: the website the video is hosted on must be one of the allowed providers below and the URL is stored in canonical form.
- **Raw footage (`raw_url`)**: accepts any valid URL. If it matches a recognized provider it is standardized, otherwise it is stored as-is.

### Completion video (`video_url`)
The following URL types are accepted (query params not listed below are ignored):

- **YouTube** (hosts: `youtube.com`, `www.youtube.com`, `m.youtube.com`, `youtu.be`)
    - `https://youtu.be/<id>`
    - `https://www.youtube.com/watch?v=<id>`
    - `https://www.youtube.com/shorts/<id>`
    - `https://www.youtube.com/live/<id>`
    - Supported query params:
        - `t` or `start`: timestamp (seconds like `90` or `1h2m3s`)
        - `list`: playlist id
    - Normalized to: `https://www.youtube.com/watch?v=<id>[&t=...][&list=...]`

- **Vimeo** (hosts: `vimeo.com`, `www.vimeo.com`, `player.vimeo.com`)
    - `https://vimeo.com/<id>`
    - `https://player.vimeo.com/video/<id>`
    - Normalized to: `https://vimeo.com/<id>`

- **Twitch** (hosts: `twitch.tv`, `www.twitch.tv`, `player.twitch.tv`)
    - `https://www.twitch.tv/videos/<id>`
    - `https://www.twitch.tv/<channel>/video/<id>`
    - `https://www.twitch.tv/<channel>/v/<id>`
    - `https://player.twitch.tv/?video=v<id>`
    - Supported query params:
        - `t` or `time`: timestamp
    - Normalized to: `https://www.twitch.tv/videos/<id>[?t=...]`

- **BiliBili** (hosts: `bilibili.com`, `www.bilibili.com`, `m.bilibili.com`)
    - `https://www.bilibili.com/video/<id>`
    - Normalized to: `https://www.bilibili.com/video/<id>`

- **Medal** (hosts: `medal.tv`, `www.medal.tv`)
    - `https://medal.tv/clips/<id>`
    - `https://medal.tv/<lang>/clips/<id>`
    - `https://medal.tv/games/<game>/clips/<id>`
    - `https://medal.tv/<lang>/games/<game>/clips/<id>`
    - Normalized to: `https://medal.tv/clips/<id>`

- **Outplayed** (hosts: `outplayed.tv`, `www.outplayed.tv`)
    - `https://outplayed.tv/<game>/<id>`
    - Normalized to: `https://outplayed.tv/media/<id>`

### Raw footage (`raw_url`)
Recognized providers include all providers listed above plus:

- **Google Drive** (host: `drive.google.com`)
    - `https://drive.google.com/file/d/<id>`
    - `https://drive.google.com/drive/folders/<id>`
    - `https://drive.google.com/open?id=<id>`
    - `https://drive.google.com/uc?id=<id>`
    - Normalized to: `https://drive.google.com/file/d/<id>` or `https://drive.google.com/drive/folders/<id>`

- **Mega** (hosts: `mega.nz`, `www.mega.nz`)
    - `https://mega.nz/file/<id>#<key>`
    - `https://mega.nz/#!<id>!<key>`
    - Normalized to: `https://mega.nz/file/<id>#<key>`

## Privilege level and Permissions
Staff endpoints require specific permissions to be accessed.

Each role gives a certain privilege level, and each user's privilege level is the highest one given by one of their roles:

| Role | Privilege Level |
|---|---|
| **AREDL+** | 5 |
| **List Helper** | 30 |
| **List Moderator** | 50 |
| **List Admin** | 90 |
| **Developer** | 100 |
| **Owner** | 110 |

Each permission then requires the user's privilege level to be higher or equal to a certain level:

| Permission | Required Level |
|---|---|
| **SubmissionReview** | 15 |
| **RecordModify** | 20 |
| **UserModify** | 25 |
| **PlaceholderCreate** | 25 |
| **PackTierModify** | 40 |
| **PackModify** | 40 |
| **UserBan** | 45 |
| **LevelModify** | 50 |
| **MergeReview** | 50 |
| **ClanModify** | 60 |
| **NotificationsSubscribe** | 70 |
| **UserRedact** | 75 |
| **DirectMerge** | 80 |
| **RoleManage** | 85 |
| **ShiftManage** | 90 |
"#;

#[derive(OpenApi)]
#[openapi(
    nest(
        (path = "/aredl", api = aredl::ApiDoc),
        (path = "/arepl", api = arepl::ApiDoc),
        (path = "/users", api = users::ApiDoc),
        (path = "/auth", api = auth::ApiDoc),
        (path = "/roles", api = roles::ApiDoc),
        (path = "/clans", api = clans::ApiDoc),
        (path = "/notifications", api = notifications::ApiDoc),
		(path = "/health", api = health::ApiDoc),
        (path = "/shifts", api=shifts::ApiDoc),
        (path = "/utils", api=utils::ApiDoc),
	)
)]

struct MainApiDoc;
#[derive(OpenApi)]
#[openapi(
    info(
        title = "AREDL API",
        version = "2.01",

        description = API_DESCRIPTION,
    ),
    nest(
        (path = "/api", api = MainApiDoc),
    ),
    modifiers(&SecurityAddon, &StaffBadgeAddon, &ServerAddon),
)]
pub struct ApiDoc;

struct SecurityAddon;
struct StaffBadgeAddon;
struct ServerAddon;

impl Modify for ServerAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        let mut server: Server = Default::default();
        server.url = std::env::var("DOCS_API_SERVER")
            .unwrap_or_else(|_| format!("http://127.0.0.1:{}", get_secret("PORT")).to_string());
        server.description = Some("API Server".to_string());
        openapi.servers = Some(vec![server]);
    }
}
impl Modify for SecurityAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        let components = openapi.components.as_mut().unwrap();
        components.add_security_scheme(
            "api_key",
            SecurityScheme::ApiKey(ApiKey::Header(ApiKeyValue::new("api-key"))),
        );
        components.add_security_scheme(
            "access_token",
            SecurityScheme::Http(
                HttpBuilder::new()
                    .scheme(HttpAuthScheme::Bearer)
                    .bearer_format("JWT")
                    .build(),
            ),
        );
        components.add_security_scheme(
            "refresh_token",
            SecurityScheme::Http(
                HttpBuilder::new()
                    .scheme(HttpAuthScheme::Bearer)
                    .bearer_format("JWT")
                    .build(),
            ),
        );
    }
}

impl StaffBadgeAddon {
    fn create_staff_badge() -> serde_json::Value {
        json!({
            "label": "Staff Only",
            "color": "red"
        })
    }

    fn create_authed_badge() -> serde_json::Value {
        json!({
            "label": "Authed User",
            "color": "orange"
        })
    }
    fn create_authed_public_badge() -> serde_json::Value {
        json!({
            "label": "Authed User / Public",
            "color": "green"
        })
    }
    fn create_public_badge() -> serde_json::Value {
        json!({
            "label": "Public",
            "color": "green"
        })
    }

    fn process_operation(op: &mut Operation) {
        let mut badges = Vec::new();
        if let Some(summary) = op.summary.as_mut() {
            if summary.contains("[Staff]") {
                *summary = summary.replace("[Staff]", "").trim().to_string();
                badges.push(Self::create_staff_badge());
            }
            if summary.contains("[AuthPublic]") {
                *summary = summary.replace("[AuthPublic]", "").trim().to_string();
                badges.push(Self::create_authed_public_badge());
            }
            if summary.contains("[Auth]") {
                *summary = summary.replace("[Auth]", "").trim().to_string();
                badges.push(Self::create_authed_badge());
            }
            if badges.is_empty() {
                badges.push(Self::create_public_badge());
            }
        } else {
            badges.push(Self::create_public_badge());
        }
        for badge in badges {
            Self::add_badge_to_operation(op, badge);
        }
    }

    fn add_badge_to_operation(op: &mut Operation, badge: serde_json::Value) {
        let extensions = op.extensions.get_or_insert_with(|| Extensions::default());
        extensions
            .entry("x-badges".to_string())
            .and_modify(|existing| {
                if let Some(array) = existing.as_array_mut() {
                    array.push(badge.clone());
                }
            })
            .or_insert_with(|| json!([badge]));
    }

    fn add_badge_to_path_item(path_item: &mut PathItem) {
        if let Some(op) = &mut path_item.get {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.post {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.put {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.patch {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.delete {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.head {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.options {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.trace {
            Self::process_operation(op);
        }
    }
}

impl Modify for StaffBadgeAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        for (_path, path_item) in openapi.paths.paths.iter_mut() {
            Self::add_badge_to_path_item(path_item);
        }
    }
}
