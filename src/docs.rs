use crate::{aredl, arepl, auth, clans, get_secret, health, notifications, roles, shifts, users};
use serde_json::json;
use utoipa::openapi::extensions::Extensions;
use utoipa::openapi::path::Operation;
use utoipa::openapi::security::{ApiKey, ApiKeyValue, HttpAuthScheme, HttpBuilder, SecurityScheme};
use utoipa::openapi::{PathItem, Server};
use utoipa::{Modify, OpenApi};

#[derive(OpenApi)]
#[openapi(
    nest(
        (path = "/aredl", api = aredl::ApiDoc),
        (path = "/arepl", api = arepl::ApiDoc),
        (path = "/users", api = users::ApiDoc),
        (path = "/auth", api = auth::ApiDoc),
        (path = "/roles", api = roles::ApiDoc),
        (path = "/clans", api = clans::ApiDoc),
        (path = "/notifications", api = notifications::ApiDoc),
		(path = "/health", api = health::ApiDoc),
        (path = "/shifts", api=shifts::ApiDoc),
	)
)]

struct MainApiDoc;
#[derive(OpenApi)]
#[openapi(
    info(
        title = "AREDL API",
        version = "2.01",

        description = "# Welcome to the AREDL API v2 Documentation!    \n\
        ## Useful Links    \n\
        **Base URL**: [https://api.aredl.net/v2/api](https://api.aredl.net/v2/api)    \n\
        **Github Organization**: [https://github.com/All-Rated-Extreme-Demon-List/](https://github.com/All-Rated-Extreme-Demon-List/)    \n\
        **Public Website**: [https://aredl.net](https://aredl.net)    \n\
        **Discord Server**: [https://discord.gg/aredl](https://discord.gg/aredl)    \n\
        \
        ## Endpoints    \n\
        You can find below each category of endpoints and their description:    \n\n\
            | Category | Description |    \n\
            |--- |--- |    \n\
            | **AREDL** | Various endpoints for fetching AREDL data automatically generated by the database |    \n\
            | **AREDL - Levels** | Endpoints for fetching and managing the list and levels data on the AREDL |    \n\
            | **AREDL - Levels (Creators)**	| Endpoints for fetching and managing the creators list of a specific AREDL level |    \n\
            | **AREDL - Submissions** | Endpoints for fetching and managing AREDL submissions, both for users and staff |    \n\
            | **AREDL - Records** | Endpoints for fetching and managing AREDL records |    \n\
            | **AREDL - Packs** | Staff only endpoints used to manage AREDL packs. To fetch packs data, use Pack Tiers endpoints instead. |    \n\
            | **AREDL - Pack Tiers** | Endpoints to fetch and manage AREDL pack tiers |    \n\
            | **AREDL (P)** | All previous AREDL specific endpoints duplicated for platformer mode |    \n\
            | **Authentication** | Endpoints for authenticating with Discord and managing api keys |    \n\
            | **Roles** | Endpoints for fetching and managing the roles and their assigned users |    \n\
            | **Users** | Endpoints for fetching and managing the list of users |    \n\
            | **Users - Me** | Endpoints for fetching and managing the authenticated user and other related information (notifications, clan invites, ..) |    \n\
            | **Users - Merges** | Endpoints for merging users and submitting/managing merge requests |    \n\
            | **Clans** | Endpoints for fetching and managing clans, both for staff and clan leaders |    \n\
            | **Clans - Members** | Endpoints for fetching, inviting and managing members of a clan, both for staff and clan leaders/vice-leaders |    \n\
            | **Shifts** | Staff endpoints to fetch and manage staff shifts for reviewing records |    \n\
            | **Notifications** | Endpoints for opening a web socket to receive real time data from the API. Used by the AREDL Bot. |    \n\
            | **Health** | Endpoints for checking whether the API is online or not |    \n\n\
        In addition to that, endpoints are also categorized by the type of authentication they require:\n\n\
            | Type | Description |    \n\
            |--- |--- |    \n\
            | **Public** | Publicly available endpoints that do not require authentication whatsoever |    \n\
            | **Authed User** | Endpoints that require you to be authenticated but that do not require any permission |    \n\
            | **Public / Authed** | Endpoints that are publicly available but that behave differently or offer additional features if you're authenticated |    \n\
            | **Staff Only** | Endpoints that require a specific permission |    \n\n\
        You can find what type an endpoint is by looking at the tags at the top of its page\n\
        \
        ## Authentication    \n\
        You can authenticate using either a bearer token or an API key.    \n\
        There are two types of tokens:    \n\
            - **Access Token**: Used to make authenticated requests. Those are short lived, and expire after 30 minutes.    \n\
            - **Refresh Token**: Used to get a new access token. Those are long lived, and expire after 2 weeks.    \n\n\
        The refresh token can not be used to make authenticated requests on classic endpoints, but is the only one that can be used on the \
        [Refresh](#get-/api/auth/discord/refresh) endpoint to get a new access token. If the refresh token is about to expire, it will also \
        return a new refresh token. Access tokens can not be used on that endpoint.    \n\
        API keys can be created through the AREDL website settings or the [Api Key](#post-/api/auth/api-key) endpoint, and have a custom live time. You can use those as a regular bearer token.   \n\
        You can invalidate all of your account's active tokens with the [Logout All](#post-/api/auth/logout-all) endpoint.    \n\
        \
        ## Privilege level and Permissions    \n\
        Staff endpoints require specific **permissions** to be accessed.    \n\
        Each role gives a certain **privilege level**, and each user's privilege level is the **highest one** given by one of their roles:    \n\n\
            | Role | Privilege Level |    \n\
            |--- |--- |    \n\
            | **AREDL+** | 5 |    \n\
            | **List Helper** | 30 |    \n\
            | **List Moderator** | 50 |    \n\
            | **List Admin** | 90 |    \n\
            | **Developer** | 100 |    \n\
            | **Owner** | 110 |    \n\n\
        Each permission then requires the user's privilege level to be **higher or equal** to a certain level, as defined below:    \n\n\
            | Permission | Required Level |    \n\
            |--- |--- |    \n\
            | **Plus** | 5 |    \n\
            | **SubmissionReview** | 15 |    \n\
            | **RecordModify** | 20 |    \n\
            | **UserModify** | 25 |    \n\
            | **PlaceholderCreate** | 25 |    \n\
            | **PackTierModify** | 30 |    \n\
            | **PackModify** | 40 |    \n\
            | **LevelModify** | 50 |    \n\
            | **MergeReview** | 60 |    \n\
            | **ClanModify** | 70 |    \n\
            | **UserBan** | 85 |    \n\
            | **DirectMerge** | 90 |    \n\
            | **ShiftManage** | 95 |    \n\
            | **RoleManage** | 100 |    \n\n\
        ",
    ),
    nest(
        (path = "/api", api = MainApiDoc),
    ),
    modifiers(&SecurityAddon, &StaffBadgeAddon, &ServerAddon),
)]
pub struct ApiDoc;

struct SecurityAddon;
struct StaffBadgeAddon;
struct ServerAddon;

impl Modify for ServerAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        let mut server: Server = Default::default();
        server.url = std::env::var("DOCS_API_SERVER")
            .unwrap_or_else(|_| format!("http://127.0.0.1:{}", get_secret("PORT")).to_string());
        server.description = Some("API Server".to_string());
        openapi.servers = Some(vec![server]);
    }
}
impl Modify for SecurityAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        let components = openapi.components.as_mut().unwrap();
        components.add_security_scheme(
            "api_key",
            SecurityScheme::ApiKey(ApiKey::Header(ApiKeyValue::new("api-key"))),
        );
        components.add_security_scheme(
            "access_token",
            SecurityScheme::Http(
                HttpBuilder::new()
                    .scheme(HttpAuthScheme::Bearer)
                    .bearer_format("JWT")
                    .build(),
            ),
        );
        components.add_security_scheme(
            "refresh_token",
            SecurityScheme::Http(
                HttpBuilder::new()
                    .scheme(HttpAuthScheme::Bearer)
                    .bearer_format("JWT")
                    .build(),
            ),
        );
    }
}

impl StaffBadgeAddon {
    fn create_staff_badge() -> serde_json::Value {
        json!({
            "label": "Staff Only",
            "color": "red"
        })
    }

    fn create_authed_badge() -> serde_json::Value {
        json!({
            "label": "Authed User",
            "color": "orange"
        })
    }
    fn create_authed_public_badge() -> serde_json::Value {
        json!({
            "label": "Authed User / Public",
            "color": "green"
        })
    }
    fn create_public_badge() -> serde_json::Value {
        json!({
            "label": "Public",
            "color": "green"
        })
    }

    fn process_operation(op: &mut Operation) {
        let mut badges = Vec::new();
        if let Some(summary) = op.summary.as_mut() {
            if summary.contains("[Staff]") {
                *summary = summary.replace("[Staff]", "").trim().to_string();
                badges.push(Self::create_staff_badge());
            }
            if summary.contains("[AuthPublic]") {
                *summary = summary.replace("[AuthPublic]", "").trim().to_string();
                badges.push(Self::create_authed_public_badge());
            }
            if summary.contains("[Auth]") {
                *summary = summary.replace("[Auth]", "").trim().to_string();
                badges.push(Self::create_authed_badge());
            }
            if badges.is_empty() {
                badges.push(Self::create_public_badge());
            }
        } else {
            badges.push(Self::create_public_badge());
        }
        for badge in badges {
            Self::add_badge_to_operation(op, badge);
        }
    }

    fn add_badge_to_operation(op: &mut Operation, badge: serde_json::Value) {
        let extensions = op.extensions.get_or_insert_with(|| Extensions::default());
        extensions
            .entry("x-badges".to_string())
            .and_modify(|existing| {
                if let Some(array) = existing.as_array_mut() {
                    array.push(badge.clone());
                }
            })
            .or_insert_with(|| json!([badge]));
    }

    fn add_badge_to_path_item(path_item: &mut PathItem) {
        if let Some(op) = &mut path_item.get {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.post {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.put {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.patch {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.delete {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.head {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.options {
            Self::process_operation(op);
        }
        if let Some(op) = &mut path_item.trace {
            Self::process_operation(op);
        }
    }
}

impl Modify for StaffBadgeAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        for (_path, path_item) in openapi.paths.paths.iter_mut() {
            Self::add_badge_to_path_item(path_item);
        }
    }
}
